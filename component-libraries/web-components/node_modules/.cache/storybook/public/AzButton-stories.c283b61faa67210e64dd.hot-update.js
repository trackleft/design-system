"use strict";
self["webpackHotUpdate_az_digital_az_web_components"]("AzButton-stories",{

/***/ "./components/AzButton/AzButton.js":
/*!*****************************************!*\
  !*** ./components/AzButton/AzButton.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AzButton": () => (/* binding */ AzButton)
/* harmony export */ });
/* harmony import */ var _mixins_shadow_events_datalayer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../mixins/shadow-events-datalayer */ "./mixins/shadow-events-datalayer.js");
/* harmony import */ var lit_element__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lit-element */ "../../node_modules/lit-element/development/index.js");
/* harmony import */ var _mixins_delegate_focus_mixin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../mixins/delegate-focus-mixin.js */ "./mixins/delegate-focus-mixin.js");



class AzButton extends (0,_mixins_delegate_focus_mixin_js__WEBPACK_IMPORTED_MODULE_1__.DelegateFocusMixin)(lit_element__WEBPACK_IMPORTED_MODULE_0__.LitElement) {
  static get properties() {
    return {
      /**
       * Set to URL to render <a> element styled as button.
       */
      link: {
        type: String,
        reflect: true
      },
      target: {
        type: String,
        reflect: true
      },
      toggle: {
        type: String,
        reflect: true
      },
      event: {
        type: String,
        reflect: true
      },
      elmid: {
        type: String,
        reflect: true
      },
      value: {
        type: String,
        reflect: true
      }
    };
  }
  constructor() {
    super();
  }
  attributeChangedCallback(name, oldVal, newVal) {
    super.attributeChangedCallback(name, oldVal, newVal);
  }
  changeAttributes() {
    this.setAttribute('closed', 'true');
    this.setAttribute('aria-expanded', 'true');
    this.requestUpdate();
  }
  _handleClick(e) {
    (0,_mixins_shadow_events_datalayer__WEBPACK_IMPORTED_MODULE_2__.eventDataLayerPush)(e, '');
    if (this.event) {
      let event = new Event(this.event);
      document.querySelector(this.target).dispatchEvent(event);
      return;
    } else {
      let openAzOffCanvasMenu = new Event('open-az-offcanvas-menu');
      document.querySelector(this.target).dispatchEvent(openAzOffCanvasMenu);
    }
  }
  render() {
    return lit_element__WEBPACK_IMPORTED_MODULE_0__.html`
			${this.link ? lit_element__WEBPACK_IMPORTED_MODULE_0__.html`<a class="button" href="${this.link}" ?disabled="${this.disabled}" @click="${_mixins_shadow_events_datalayer__WEBPACK_IMPORTED_MODULE_2__.eventDataLayerPush}" id="${this.elmid}">${this.value}<slot></slot></a>` : lit_element__WEBPACK_IMPORTED_MODULE_0__.html`<button type="button" class="button" ?disabled="${this.disabled}" role="presentation" @click="${this._handleClick}" id="${this.elmid}">${this.value}<slot></slot></button>`}
		`;
  }
  firstUpdated() {
    super.firstUpdated();
    this.setAttribute('role', 'button');
  }

  /**
   * @protected
   */
  get focusElement() {
    return this.shadowRoot.querySelector('.button');
  }
}

/***/ }),

/***/ "./components/AzButton/index.js":
/*!**************************************!*\
  !*** ./components/AzButton/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./components/AzButton/style.css");
/* harmony import */ var _AzButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AzButton */ "./components/AzButton/AzButton.js");


customElements.get('az-button') || customElements.define('az-button', _AzButton__WEBPACK_IMPORTED_MODULE_1__.AzButton);

/***/ }),

/***/ "./mixins/delegate-focus-mixin.js":
/*!****************************************!*\
  !*** ./mixins/delegate-focus-mixin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DelegateFocusMixin": () => (/* binding */ DelegateFocusMixin)
/* harmony export */ });
const $$tabindex = Symbol('tabindex');
const $$oldTabindex = Symbol('oldTabindex');
const $$newTabindex = Symbol('newTabindex');
const DelegateFocusMixin = superClass => class extends superClass {
  static get properties() {
    return {
      tabIndex: {
        converter: {
          fromAttribute: Number,
          toAttribute: value => value == null ? null : value.toString()
        },
        noAccessor: true,
        reflect: true
      },
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflect: true
      }
    };
  }
  constructor() {
    super();
    if (!this.hasAttribute('tabindex')) {
      this.tabIndex = 0;
    }
  }
  get tabIndex() {
    return this[$$tabindex];
  }
  set tabIndex(value) {
    const oldValue = this[$$tabindex];
    this[$$tabindex] = value;
    this.requestUpdate('tabIndex', oldValue);
  }
  firstUpdated() {
    this.addEventListener('focusin', e => {
      if (e.composedPath()[0] === this) {
        this._focus();
      }
    });
    this.addEventListener('keydown', e => {
      if (!e.defaultPrevented && e.shiftKey && e.keyCode === 9) {
        // Flag is checked in _focus event handler.
        this._isShiftTabbing = true;
        HTMLElement.prototype.focus.apply(this);
        // Event handling in IE is asynchronous and the flag is removed asynchronously as well
        setTimeout(() => {
          this._isShiftTabbing = false;
        }, 0);
      }
    });
  }
  update(props) {
    if (props.has('disabled')) {
      this._disabledChanged(this.disabled, props.get('disabled'));
    }
    if (props.has('tabIndex')) {
      // save value of tabindex, as it can be overridden to
      // undefined in case if the element is disabled
      this[$$newTabindex] = this.tabIndex;
      this._tabIndexChanged(this.tabIndex);
    }
    super.update(props);
  }
  updated(props) {
    super.updated(props);
    if (props.has('disabled')) {
      this.focusElement.disabled = this.disabled;
      if (this.disabled) {
        this.blur();
      }
    }
    if (props.has('tabIndex') && this[$$newTabindex] !== undefined) {
      this.focusElement.tabIndex = this[$$newTabindex];
      this[$$newTabindex] = undefined;
    }
  }

  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the actual focusable element in the component.
   */
  get focusElement() {
    window.console.warn(`Please implement the 'focusElement' property in <${this.localName}>`);
    return this;
  }
  _focus() {
    if (this._isShiftTabbing) {
      return;
    }
    this.focusElement.focus();
  }

  /**
   * Moving the focus from the host element causes firing of the blur event what leads to problems in IE.
   * @protected
   */
  focus() {
    if (this.disabled) {
      return;
    }
    this.focusElement.focus();
  }

  /**
   * Native bluring in the host element does nothing because it does not have the focus.
   * In chrome it works, but not in FF.
   * @protected
   */
  blur() {
    this.focusElement.blur();
  }
  _disabledChanged(disabled, oldDisabled) {
    if (disabled) {
      this[$$oldTabindex] = this.tabIndex;
      this.tabIndex = -1;
      this.setAttribute('aria-disabled', 'true');
    } else if (oldDisabled) {
      if (this[$$oldTabindex] !== undefined) {
        this.tabIndex = this[$$oldTabindex];
      }
      this.removeAttribute('aria-disabled');
    }
  }
  _tabIndexChanged(tabindex) {
    if (this.disabled && tabindex) {
      // If tabindex attribute was changed while checkbox was disabled
      if (this.tabIndex !== -1) {
        this[$$oldTabindex] = this.tabIndex;
      }
      this.tabIndex = null;
    }
  }
};

/***/ }),

/***/ "./mixins/shadow-events-datalayer.js":
/*!*******************************************!*\
  !*** ./mixins/shadow-events-datalayer.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eventDataLayerPush": () => (/* binding */ eventDataLayerPush)
/* harmony export */ });
const eventDataLayerPush = (e, location = '') => {
  // Add window.dataLayer if doesnt exist
  window.dataLayer = window.dataLayer || [];
  // Fetch reference to the element that was actually clicked
  var targetElement = e.composedPath()[0];
  // Fetch reference to the element's parent dropdown which was clicked
  var parentDropDown = e.composedPath()[3].innerText ? e.composedPath()[3].innerText.split("\n")[0] : '';
  window.dataLayer.push({
    event: 'shadow_event_' + e.type,
    shadow_event: {
      elementInnerHTML: targetElement.textContent || '',
      elementInnerText: targetElement.innerText || '',
      title: 'shadow-dom-link',
      element: targetElement,
      elementClasses: targetElement.className || '',
      elementId: targetElement.id || '',
      elementLocation: location || '',
      elementTarget: targetElement.target || '',
      elementUrl: targetElement.href || targetElement.action || '',
      originalEvent: e,
      parent: parentDropDown || "",
      inShadowDom: true
    }
  });
};

/***/ })

});
//# sourceMappingURL=AzButton-stories.c283b61faa67210e64dd.hot-update.js.map